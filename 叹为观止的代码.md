## 1.简单难度

### 1.1交换工资

给定一个 `salary`表，如下所示，有m=男性 和 f=女性的值 。交换所有的 f 和 m 值(例如，将所有 f 值更改为 m，反之亦然)。要求使用一个更新查询，并且没有中间临时表。

例如:

```
| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |
```

运行你所编写的查询语句之后，将会得到以下表:

```
| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |
```

#### **答案**

```mysql
update salary set sex = CHAR(ASCII('m')^ASCII('f')^ASCII(sex))
```

#### 思路

m^f^sex 

0001 ^ 0001 = 0000 ^ 0010 = 0010 即 自己和自己异或则会变为空，再与其他异或时即等于效果



### 1.2汉明距离

两个整数之间的[汉明距离](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB)指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 `x` 和 `y`，计算它们之间的汉明距离。

**注意：**
0 ≤ `x`, `y` < 231.

**示例:**

```
输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

上面的箭头指出了对应二进制位不同的位置。
```

#### **答案**

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int temp = x ^ y;
        int res = 0;
        while(temp != 0){
            res++;
            temp &= (temp-1);
        }
        return res;
    }
}

```

#### 思路

^ 异或  两者不同则为1  0001 ^ 0100 = 0101

& 并 两者相同则为1 0001 | 0100 = 0000

| 或 一者为1则都为1 0001 | 0100 = 0101 

1.0001^0100 =  0101

2.0101 & 0011 = 0001 每换一次位，即对前面的一位退位,然后与之前比较,导致并运算使头部清0。如果用temp-1 则会导致 0100 和 1000 这种需要换2次位，计算之后 的1100 要退很多次

这里的数字大小是没有意义的，只有位置是有意义的。



### 1.3唯一摩尔斯密码词

国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: `"a"` 对应 `".-"`, `"b"`对应 `"-..."`, `"c"` 对应 `"-.-."`, 等等。

为了方便，所有26个英文字母对应摩尔斯密码表如下：

```
[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
```

给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，"cab" 可以写成 "-.-.-....-"，(即 "-.-." + "-..." + ".-"字符串的结合)。我们将这样一个连接过程称作单词翻译。

返回我们可以获得所有词不同单词翻译的数量。

```
例如:
输入: words = ["gin", "zen", "gig", "msg"]
输出: 2
解释: 
各单词翻译如下:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

共有 2 种不同翻译, "--...-." 和 "--...--.".
```

#### **答案**

```java
class Solution {
    public int uniqueMorseRepresentations(String[] words) {
        String[] password = {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
        Set<String> resp = new HashSet();
        for(String s : words){
            char[] val = s.toCharArray();
            StringBuilder sb = new StringBuilder();
            for (char c : val){
                sb.append(password[c-'a']);
            }
            resp.add(sb.toString());
        }
        return resp.size();
    }
}
```

#### 思路

将所有的字符-a 即从0-26下标 ，用set去重计数即可。



### 1.4数组拆分 I

给定长度为 **2n** 的数组, 你的任务是将这些数分成 **n** 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。

**示例 1:**

```
输入: [1,4,3,2]

输出: 4
解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).
```

**提示:**

1. **n** 是正整数,范围在 [1, 10000].
2. 数组中的元素范围在 [-10000, 10000].

#### 答案

```java
class Solution {
    // 需要将数字排序，最接近的数字组成一对
    //1.可以将数组先排序，再将奇数位的数字相加
    //2.可以用一个辅助数组，将辅助数组中下标为（数组中的某个值）的位置置1,其余位置默认是0。在遍历辅助数组，
    //  如果某个位置的值为1,表明有一个数值为下标-10000，-10000是因为要分10000个位置给负数
    //  而且要隔一个数字相加
    public int arrayPairSum(int[] nums) {
        int[] count = new int[20001];
        for (int n : nums) {
            count[n + 10000]++;//表示下标为n + 10000有数字
        }
        boolean odd = true;
        int sum = 0;
        for (int i = 0; i < count.length; i++) {
            while (count[i] > 0) {
                if (odd) {
                    sum += i - 10000;
                }
                odd = !odd;//要隔一个数字相加
                count[i]--;
            }
        }
        return sum;
        
    }

}
```

#### 思路

可以用一个辅助数组，将辅助数组中下标为（数组中的某个值）的位置置1,其余位置默认是0。在遍历辅助数组。

将数字排序放入数组的下标中，存在几个则存为val，跳着相加即可。



###  1.5二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶节点的最长路径上的节点数。

**案例：**
给出二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回最大深度为 3 。

#### **答案**

```
public int maxDepth(T.TreeNode root) {
   if(root == null) {
      return 0;
   }

   return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

#### 思路

null层为0 null层上面+1 以此类推，取左右最大值



### 1.6两整数之和

**不使用**运算符 `+` 和`-`，计算两整数`a` 、`b`之和。

**示例：**
若 *a* = 1 ，*b* = 2，返回 3。

#### 答案

```java
public int getSum(int c, int d) {
        //判断是否有进位项 如果没有则直接返回
        if((c&d) == 0){
            return c^d;
        }
        //c^d 将所有不需要进位的项保留， c&d 将所有进位项捕获 <<1 使所有进位项 进位
        return getSum(c^d,(c&d)<<1);
    }
```

#### 思路

注释



