## 1.简单难度

### 1.1交换工资

给定一个 `salary`表，如下所示，有m=男性 和 f=女性的值 。交换所有的 f 和 m 值(例如，将所有 f 值更改为 m，反之亦然)。要求使用一个更新查询，并且没有中间临时表。

例如:

```
| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |
```

运行你所编写的查询语句之后，将会得到以下表:

```
| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |
```

#### **答案**

```mysql
update salary set sex = CHAR(ASCII('m')^ASCII('f')^ASCII(sex))
```

#### 思路

m^f^sex 

0001 ^ 0001 = 0000 ^ 0010 = 0010 即 自己和自己异或则会变为空，再与其他异或时即等于效果



### 1.2汉明距离

两个整数之间的[汉明距离](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB)指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 `x` 和 `y`，计算它们之间的汉明距离。

**注意：**
0 ≤ `x`, `y` < 231.

**示例:**

```
输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

上面的箭头指出了对应二进制位不同的位置。
```

#### **答案**

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int temp = x ^ y;
        int res = 0;
        while(temp != 0){
            res++;
            temp &= (temp-1);
        }
        return res;
    }
}

```

#### 思路

^ 异或  两者不同则为1  0001 ^ 0100 = 0101

& 并 两者相同则为1 0001 | 0100 = 0000

| 或 一者为1则都为1 0001 | 0100 = 0101 

1.0001^0100 =  0101

2.0101 & 0011 = 0001 每换一次位，即对前面的一位退位,然后与之前比较,导致并运算使头部清0。如果用temp-1 则会导致 0100 和 1000 这种需要换2次位，计算之后 的1100 要退很多次

这里的数字大小是没有意义的，只有位置是有意义的。



### 1.3唯一摩尔斯密码词

国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: `"a"` 对应 `".-"`, `"b"`对应 `"-..."`, `"c"` 对应 `"-.-."`, 等等。

为了方便，所有26个英文字母对应摩尔斯密码表如下：

```
[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
```

给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，"cab" 可以写成 "-.-.-....-"，(即 "-.-." + "-..." + ".-"字符串的结合)。我们将这样一个连接过程称作单词翻译。

返回我们可以获得所有词不同单词翻译的数量。

```
例如:
输入: words = ["gin", "zen", "gig", "msg"]
输出: 2
解释: 
各单词翻译如下:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

共有 2 种不同翻译, "--...-." 和 "--...--.".
```

#### **答案**

```java
class Solution {
    public int uniqueMorseRepresentations(String[] words) {
        String[] password = {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
        Set<String> resp = new HashSet();
        for(String s : words){
            char[] val = s.toCharArray();
            StringBuilder sb = new StringBuilder();
            for (char c : val){
                sb.append(password[c-'a']);
            }
            resp.add(sb.toString());
        }
        return resp.size();
    }
}
```

#### 思路

将所有的字符-a 即从0-26下标 ，用set去重计数即可。



### 1.4数组拆分 I

给定长度为 **2n** 的数组, 你的任务是将这些数分成 **n** 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。

**示例 1:**

```
输入: [1,4,3,2]

输出: 4
解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).
```

**提示:**

1. **n** 是正整数,范围在 [1, 10000].
2. 数组中的元素范围在 [-10000, 10000].

#### 答案

```java
class Solution {
    // 需要将数字排序，最接近的数字组成一对
    //1.可以将数组先排序，再将奇数位的数字相加
    //2.可以用一个辅助数组，将辅助数组中下标为（数组中的某个值）的位置置1,其余位置默认是0。在遍历辅助数组，
    //  如果某个位置的值为1,表明有一个数值为下标-10000，-10000是因为要分10000个位置给负数
    //  而且要隔一个数字相加
    public int arrayPairSum(int[] nums) {
        int[] count = new int[20001];
        for (int n : nums) {
            count[n + 10000]++;//表示下标为n + 10000有数字
        }
        boolean odd = true;
        int sum = 0;
        for (int i = 0; i < count.length; i++) {
            while (count[i] > 0) {
                if (odd) {
                    sum += i - 10000;
                }
                odd = !odd;//要隔一个数字相加
                count[i]--;
            }
        }
        return sum;
        
    }

}
```

#### 思路

可以用一个辅助数组，将辅助数组中下标为（数组中的某个值）的位置置1,其余位置默认是0。在遍历辅助数组。

将数字排序放入数组的下标中，存在几个则存为val，跳着相加即可。



###  1.5二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶节点的最长路径上的节点数。

**案例：**
给出二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回最大深度为 3 。

#### **答案**

```
public int maxDepth(T.TreeNode root) {
   if(root == null) {
      return 0;
   }

   return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

#### 思路

null层为0 null层上面+1 以此类推，取左右最大值



### 1.6两整数之和

**不使用**运算符 `+` 和`-`，计算两整数`a` 、`b`之和。

**示例：**
若 *a* = 1 ，*b* = 2，返回 3。

#### 答案

```java
class Solution {
    public int getSum(int c, int d) {
        //判断是否有进位项 如果没有则直接返回
        if((c&d) == 0){
            return c^d;
        }
        //c^d 将所有不需要进位的项保留， c&d 将所有进位项捕获 <<1 使所有进位项 进位
        return getSum(c^d,(c&d)<<1);
    }
}
```

#### 思路

注释

### 1.7子域名访问计数

一个网站域名，如"discuss.leetcode.com"，包含了多个子域名。作为顶级域名，常用的有"com"，下一级则有"leetcode.com"，最低的一级为"discuss.leetcode.com"。当我们访问域名"discuss.leetcode.com"时，也同时访问了其父域名"leetcode.com"以及顶级域名 "com"。

给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如："9001 discuss.leetcode.com"。

接下来会给出一组访问次数和域名组合的列表`cpdomains` 。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。

```
示例 1:
输入: 
["9001 discuss.leetcode.com"]
输出: 
["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"]
说明: 
例子中仅包含一个网站域名："discuss.leetcode.com"。按照前文假设，子域名"leetcode.com"和"com"都会被访问，所以它们都被访问了9001次。
```

```
示例 2
输入: 
["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]
输出: 
["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"]
说明: 
按照假设，会访问"google.mail.com" 900次，"yahoo.com" 50次，"intel.mail.com" 1次，"wiki.org" 5次。
而对于父域名，会访问"mail.com" 900+1 = 901次，"com" 900 + 50 + 1 = 951次，和 "org" 5 次。
```

**注意事项：**

-  `cpdomains` 的长度小于 `100`。
- 每个域名的长度小于`100`。
- 每个域名地址包含一个或两个"."符号。
- 输入中任意一个域名的访问次数都小于`10000`。

#### 答案

```java
class Solution {
   public List<String> subdomainVisits(String[] cpdomains) {
        HashMap<String, Integer> map = new HashMap<>();
        for(String domain : cpdomains){
            if(domain.length() == 0) continue;
            int index = domain.indexOf(' ');
            int time = Integer.valueOf(domain.substring(0, index));
            domain = domain.substring(index + 1);
            map.put(domain, map.getOrDefault(domain, 0) + time);
            while(domain.indexOf('.') != -1){
                domain = domain.substring(domain.indexOf('.') + 1);
                map.put(domaim, map.getOrDefault(domain, 0) + time);
            }
        }
        List<String> ans = new ArrayList<>();
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            String s = entry.getValue() + " " +  entry.getKey();
            ans.add(s);
        }
        return ans;
    }
}
```

#### 思路

截取字符串解决

### 1.8岛屿的周长

给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

**示例 :**

![示例图](https://leetcode-cn.com/static/images/problemset/island.png)

```
[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]
答案: 16
解释: 它的周长是下面图片中的 16 个黄色的边：
```

#### 答案

```java
class Solution {
    public int islandPerimeter(int[][] grid) {

		int sum = 0;
		int neighbor = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {
				if (grid[i][j] == 1) {
					sum++;
					if (i < grid.length - 1 && grid[i + 1][j] == 1) {
						neighbor++;
					}
					if (j < grid[i].length - 1 && grid[i][j + 1] == 1) {
						neighbor++;
					}
				}
			}
		}
		return sum * 4 - neighbor * 2;
	
    }
}
```

#### 思路

只判断下右 ，是1 就++ 下右有邻居就邻居++ 之后每1个邻居会导致重合的线有2条

数目*4 - 重合线(邻居) * 2 得解 